/*************************************************************************************/
/* This is a new drive system that I found and modified for the team's use.  *********/
/* Basically, its for mecanum but can be addapted for use for omni.  *****************/
/* How it works - When you press 5, it sets the curent "compass north" of the robot. */
/* You can then use the left joystick to manuever the field using that compass north */
/* as your 'front of robot'.  This coupled with rotation on the x-axis of the second */
/* joystick can allow you complete control of the robots movement.  Now, when the 5 **/
/* button on the joystick is not depressed, the robot will act just like any other ***/
/* mecanum bot and the "compass north" will be the front of the robot.  I hope that **/
/* this helps a lot and that you kick some ass at worlds!  If it doesn't work, get in*/
/* contact with me and I will try to help you debug it.  I urge you to read through **/
/* code so that you can have some understanding of how the thing works.  Good luck! **/
/************************************************ Designed and coded by Ben Weis *****/

#pragma config(Hubs,  S1, HTMotor,  HTMotor,  none,     none)
#pragma config(Sensor, S1,     ,               sensorI2CMuxController)
#pragma config(Sensor, S4,     gyro,           sensorI2CHiTechnicGyro)
#pragma config(Motor,  mtr_S1_C1_1,     FL,            tmotorTetrix, openLoop, reversed)
#pragma config(Motor,  mtr_S1_C1_2,     BL,            tmotorTetrix, openLoop, reversed)
#pragma config(Motor,  mtr_S1_C2_1,     FR,            tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C2_2,     BR,            tmotorTetrix, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#include "JoystickDriver.c"	// Include file to "handle" the Bluetooth messages.

float initial; 	//initial gyro reading
float heading; 	//robots current yaw
float radheading;   //heading in radians
int lastTime = 0;	//last time header was updated, used to find average change in rotation

float FLset; //front-left set, refers to Front-Left and Back-Right
float FRset; //front-right set, refers to Front-Right and Back-Left motor

float joyAngle; // angle of the first joystick


// sets the motor sets to move at certain speeds depending on the vector given
void moveDirection(float angle, float magnitude){
	FLset = magnitude * (cos(angle) + sin(angle));  //sin(x) + cos(x)
	FRset = magnitude * (sin(angle) - cos(angle));	//sin(x) - cos(x)
}

//Initilizes the robot before anything begins moving, retrieves average base gyro reading etc.
void initializeRobot() {
	for(int i = 0; i < 100; i++){
		initial += SensorValue[S4];
		wait10Msec(1);
	}
	initial = initial / 100;
	return;
}

// This is the superdrive task. If you can think of any better names, please tell me :P
// This task incorporates two modes, regular mecanum driving and free-spinning mode
task superDrive() {
    float x1 = 0;   //x-axis on left joystick /2
    float y1 = 0;   //y-axis on left joystick /2
    float x2 = 0;   //x-axis on right joystick /2
    float y2 = 0;   //y-axis on left joystick /2
    
    float LF = 0;   //polished motor value from -100 to 100 to front left motor
    float RF = 0;   //polished motor value from -100 to 100 to front right motor
    float LB = 0;   //polished motor value from -100 to 100 to back left motor
    float RB = 0;   //polished motor value from -100 to 100 to back right motor

    int minJoy = 12;    //minimum joystick value threshhold

    float turning;
    float mag;          // magnitude of the joystick vector
    float initialHeading = radheading;

    float calcHeading = radheading; // sets calculated heading

    // for apportioning power to turning and moving, ensures consistant movement.
    float movementAmount;
    float turningAmount;
    float totalAmount;

    while(true){
        //define values for joysticks divided in half
    	x1 = joystick.joy1_x1 * .5;
    	y1 = joystick.joy1_y1 * .5;
    	x2 = joystick.joy1_x2 * .5;
    	y2 = joystick.joy1_y2 * .5;

		// when 5 is pressed, you set the current heading for your bot.
    	if (joy1Btn(5) == 1){
    		initialHeading = radheading;
    	}

		// starts free-spinning mode when 6 is held down.
    	if (joy1Btn(6) == 1){

			// find joystick vector angle (atan2 is for radians)
    		joyAngle = atan2(y1, x1);

	        	// find joystick vector magnitude
			mag = sqrt(x1 * x1 + y1 * y1) / 2; // sqrt(a^2 + b^2) /2
			// caps max magnitude at 64
			if (mag > 64)
				mag = 64;
			
			// get calculated heading
			calcHeading = radheading - initialHeading;
			
			// find the direction needed to move
			moveDirection(joyAngle + calcHeading, mag);

			// fix drifting with min joystick threshold
			if (abs(joystick.joy1_x1) < minJoy && abs(joystick.joy1_y1) < minJoy){
				FLset = 0;
				FRset = 0;
			}

			// find turning magnitude
			turning = x2/2;

			//fix turning drifting
			if (abs(joystick.joy1_x2)<minJoy){
				turning = 0;
			}
			
			// apportion total motor capacity to movement and turning (max power is 128, so all parts need to be scaled)
			// ****TODO make this better... although that will be difficult... ****
			totalAmount = 1 + turning + mag * 3;
			movementAmount = (mag*3)/totalAmount;
			turningAmount = turning/totalAmount;

        	// Apply finished values to motors
			motor[FL] = FLset * movementAmount + turning * turningAmount;
			motor[FR] = FRset * movementAmount - turning * turningAmount;
			motor[BL] = FRset * movementAmount + turning * turningAmount;
			motor[BR] = FLset * movementAmount - turning * turningAmount;
		}

		else {	//if 6 isn't held down, its driven like a normal bot
    	
	    	// Resets movement values
			LF = 0;
			RF = 0;
			LB = 0;
			RB = 0;

	    	// Get joystick values
			x1 = joystick.joy1_x1 * .5;
			y1 = joystick.joy1_y1 * .5;
			x2 = joystick.joy1_x2 * .5;
			y2 = joystick.joy1_y2 * .5;

	    	// Handle Strafing Movement
			LF += x1;
			RF -= x1;
			LB -= x1;
			RB += x1;

	    	// Handle Regular Movement
			LF += y1;
			RF += y1;
			LB += y1;
			RB += y1;

	    	// Handle Turning Movement
			LF += x2;
			RF -= x2;
			LB += x2;
			RB -= x2;

			//checks that if all joystick values are less than minJoy, that all motor power is stopped.
			if ( (abs(joystick.joy1_x1) < minJoy) && (abs(joystick.joy1_y1) < minJoy) && (abs(joystick.joy1_x2) < minJoy)) {
				LF = 0;
				RF = 0;
				LB = 0;
				RB = 0;
			}

	    	// Apply polished values to motors.
			motor[FL] = LF;
			motor[FR] = RF;
			motor[BL] = LB;
			motor[BR] = RB;
		}

		wait1Msec(10); //time for other tasks to run
	}
}

//basic mecanum wheel drive  (To use this one rather than superdrive, see the main task.
task drive(){
	float x1 = 0;   //x-axis on left joystick /2
    float y1 = 0;   //y-axis on left joystick /2
    float x2 = 0;   //x-axis on right joystick /2
    float y2 = 0;   //y-axis on left joystick /2
    
    float LF = 0;   //polished motor value from -100 to 100 to front left motor
    float RF = 0;   //polished motor value from -100 to 100 to front right motor
    float LB = 0;   //polished motor value from -100 to 100 to back left motor
    float RB = 0;   //polished motor value from -100 to 100 to back right motor
    
	int minJoy = 12;    // minimum joy value threshold

	while(true){
		// Resets movement values
		LF = 0;
		RF = 0;
		LB = 0;
		RB = 0;
		
        // Get joystick values
		x1 = joystick.joy1_x1 * .5;
		y1 = joystick.joy1_y1 * .5;
		x2 = joystick.joy1_x2 * .5;
		y2 = joystick.joy1_y2 * .5;

		// Handle Strafing Movement
		LF += x1;
		RF -= x1;
		LB -= x1;
		RB += x1;
		
        // Handle Regular Movement
		LF += y1;
		RF += y1;
		LB += y1;
		RB += y1;
		
        // Handle Turning Movement
		LF += x2;
		RF -= x2;
		LB += x2;
		RB -= x2;

        //checks that if all joystick values are less than minJoy, that all motor power is stopped.
		if ( (abs(joystick.joy1_x1) < minJoy) && (abs(joystick.joy1_y1) < minJoy) && (abs(joystick.joy1_x2) < minJoy)) {
			LF = 0;
			RF = 0;
			LB = 0;
			RB = 0;
		}

		// Apply Finished values to motors.
		motor[FL] = LF;
		motor[FR] = RF;
		motor[BL] = LB;
		motor[BR] = RB;

        // necessary if using task control to allow for other tasks to run
		wait1Msec(10);
	}
}

// This task finds the heading of the robot using the gyro.
// Keep in mind that this needs the code written in the initializeRobot() function to work
task heading() {
	ClearTimer(T1); // sets timer to 0
	while(true){
		int currentReading = SensorValue[gyro] - initial; // gets the new sensor reading
		heading += (currentReading) * (time1[T1] - lastTime) * .001; // modifies the header
		lastTime = time1[T1]; // sets the last time for the next reading
		
        // this resets the timer after 30 seconds because the timer can only count to 32 seconds
		if (time1[T1]>30000){
			ClearTimer(T1);
			lastTime = 0;
		}

        // the heading expressed in radians
		radheading = heading/180*PI;
		
        // lets other tasks run
		wait1Msec(10);
	}
}

// This is a task mostly for debugging. It displays values for the heading and joystick angle
// This task is not essential and can be deleted
task display(){
	while (true){
		eraseDisplay();
		nxtDisplayCenteredTextLine(0, "Heading: %d", heading);
		nxtDisplayCenteredTextLine(1, "joyAngle: %d", joyAngle);
		wait1Msec(20);
	}
}


//main body of code.  This runs after initiallization and will stay running.
task main(){
	initializeRobot();

    // wait for start of tele-op phase
	waitForStart();

    // starts task for displaying heading and joystick angle
	StartTask(display);

    //actively calculates current robot heading
	StartTask(heading);

    //StartTask(drive);   //if you want to use standard drive, uncomment this line and comment out the superdrive task
	StartTask(superDrive);

    //keep this infinite loop, it is essention to not end code after starting tasks
	while (true){
		wait1Msec(10000);
	}
}
