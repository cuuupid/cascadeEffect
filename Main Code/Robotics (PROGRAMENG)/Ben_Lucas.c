#pragma config(Hubs,  S1, HTMotor,  HTMotor,  none,     none)
#pragma config(Sensor, S2,     Gyro,           sensorAnalogInactive)
#pragma config(Sensor, S3,     Sonar,          sensorSONAR)
#pragma config(Sensor, S4,     Accel,          sensorI2CHiTechnicAccel)
#pragma config(Motor,  mtr_S1_C1_1,     frontright,    tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C1_2,     backright,     tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C2_1,     frontleft,     tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C2_2,     backleft,      tmotorTetrix, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#include "JoystickDriver.c"
#include "hitechnic-gyro.h"

float initial; 	//initial gyro reading
float heading; 	//robots current yaw
float radheading;   //heading in radians
int lastTime = 0;	//last time header was updated, used to find average change in rotation
float FLset; //front-left set, refers to Front-Left and Back-Right
float FRset; //front-right set, refers to Front-Right and Back-Left motor
float joyAngle; // angle of the first joystick
float currHeading;
float sonarValue;
float delTime = 0;//calibration
float prevHeading = 0;
float curRate = 0;

void motorTrigger(tMotor motorCall,int x,int y,int z);


void initializeRobot()
{
	for(int i = 0; i < 100; i++){
		initial += SensorValue[S4];
		wait10Msec(1);
	}
	initial = initial / 100;
	return;
}

task FPSDrive()
{
 int deadZone = 15;
	while(true)
	{
		int accelValue = SensorValue(Accel);
		int gyroValue = SensorValue(Gyro);

	nxtDisplayCenteredBigTextLine(5,"%d",gyroValue);
	nxtDisplayCenteredBigTextLine(5,"%d",accelValue);

		getJoystickSettings(joystick);

		int y= joystick.joy1_y1;
		int x= joystick.joy1_x1;
		int z= joystick.joy1_x2;

		int trueX = (cosDegrees(currHeading)*x)-(sinDegrees(currHeading)*y);
		int trueY = (sinDegrees(currHeading)*x)+(cosDegrees(currHeading)*y);

		x = trueX;
		y = trueY;

	if ( (abs(joystick.joy1_x1) < deadZone) && (abs(joystick.joy1_y1) < deadZone) && (abs(joystick.joy1_x2) < deadZone))
		{
			x = 0;
			y = 0;
			z = 0;
		}

		motorTrigger(frontright,x,-y,-z);
		motorTrigger(backright,-x,-y,-z);
		motorTrigger(frontleft,x,y,-z);
		motorTrigger(backleft,-x,y,-z);
	}
}

task getHeading() {


  HTGYROstartCal(Gyro);
  PlaySound(soundBeepBeep);
  while (true) {
    time1[T1] = 0;
    curRate = HTGYROreadRot(Gyro);
    if (abs(curRate) > 3) {
      prevHeading = currHeading;
      currHeading = prevHeading + curRate * delTime;
      if (currHeading > 360) currHeading -= 360;
      else if (currHeading < 0) currHeading += 360;
    }
    wait1Msec(5);
    delTime = ((float)time1[T1]) / 1000;
  }
}

void motorTrigger(tMotor motorCall,int x,int y,int z)
{
	 	motor[motorCall]= (y+x+z);
}


task   getXY()
{  //365.76

}//18in = 45.72

task display()
{
	while (true){
		eraseDisplay();
		nxtDisplayCenteredTextLine(0, "Heading: %d", currHeading);
		nxtDisplayCenteredTextLine(1, "joyAngle: %d", joyAngle);
		nxtDisplayCenteredTextLine(2, "Sonar: %d", sonarValue);
		wait1Msec(20);
	}
}

task getSonar()
{
	while(true){
sonarValue = SensorValue(Sonar);}
}

task getAccel()
{
int X_Accel;
int Y_Accel;

//X_Accel = SensorValue[xAxis]/2000;
//Y_Accel = SensorValue[yAxis];

}

task calibrateDrive()//needs work, doing some wack stuff
{
	while(true)
	{
		if(joy1Btn(1)&&joy1Btn(3))
		{
				PlaySound(soundUpwardTones);
				wait1Msec(500);
		/*

			initializeRobot();
			HTGYROstartCal(Gyro);
			delTime = 0;//calibration
			prevHeading = 0;
			curRate = 0;
    	wait1Msec(500);
		*/
    }
	}
}

task main()
{
	initializeRobot();
	StartTask(display);
	StartTask(getHeading);
	StartTask(FPSDrive);
	StartTask(getSonar);
	StartTask(calibrateDrive);
  while (true){
		wait1Msec(10000);
	}

}
